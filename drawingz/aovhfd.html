<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Angle of view</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <style>
        html {
            font-family: sans-serif;
        }

        .annot {
            font-size: 10pt;
        }

        .center {
            text-anchor: middle;
        }

        .vcenter {
            dominant-baseline: middle;
        }

        .ralign {
            text-anchor: end;
        }

        .light {
            fill: #b0b0b0;
        }
    </style>
</head>

<body>
    <h1>Horizontal angle and field of view</h1>
    <div>
        <input type="text" id="inpFocallengths">
        <button id="cmdFocallengths">Foo!</button>
    </div>
    <p>Ticks are at 5&deg; for angle of view and at 1m for field of view (for an object plane distance of 10m).</p>
    <div id="aov">
        <svg id="aov_svg" xmlns="http://www.w3.org/2000/svg"></svg>
    </div>

    <h1>Hyperfocal distance</h1>
    <p>Hyperfocal distance in meters for typical f-numbers and a 35mm full frame sensor.</p>
    <div id="hfd">
        <svg id="hfd_svg" xmlns="http://www.w3.org/2000/svg"></svg>
    </div>

    <script>

        // Returns the angle of view for the given focal length.
        function aov(focal_length, sensor_width = 36) {
            return 2 * Math.atan(sensor_width / (2 * focal_length));
        }

        // Returns the hyperfocal distance.
        function hfd(focal_length, f_number, coc = 0.03) {
            return (focal_length * focal_length) / (f_number * coc) + focal_length;
        }

        function svgPath(p) {
            const path = document.createElementNS("http://www.w3.org/2000/svg", 'path');
            path.setAttribute("d", p.d);
            if (p.fill) {
                path.style.fill = p.fill;
            }
            if (p.stroke) {
                path.style.stroke = p.stroke;
            }
            if (p.style) {
                Object.keys(p.style).forEach(k => { path.style[k] = p.style[k]; });
            }
            return path;
        }

        class SvgCircleSegment {
            constructor(cx, cy, r, phi0, phi1, includeCenterPoint, style) {
                if (phi0 > phi1) {
                    // Ensure phi0 <= phi1.
                    phi0 -= Math.ceil((phi0 - phi1) / (Math.PI * 2)) * Math.PI * 2;
                }
                this.cx = cx;
                this.cy = cy;
                this.r = r;
                this.phi0 = phi0;
                this.phi1 = phi1;
                this.includeCenterPoint = includeCenterPoint;
                this.style = style;
            }
            get x0() {
                return this.cx + this.r * Math.cos(this.phi0);
            }
            get y0() {
                return this.cy + this.r * Math.sin(this.phi0);
            }
            get x1() {
                return this.cx + this.r * Math.cos(this.phi1);
            }
            get y1() {
                return this.cy + this.r * Math.sin(this.phi1);
            }
            svg() {
                let large_arc_flag = +(this.phi1 - this.phi0 > Math.PI);
                let sweep_flag = 1;  // always go clockwise (which looks like counter-clockwise due to the y-axis flip in SVG).
                let d = `M ${this.x0} ${this.y0} A ${this.r} ${this.r} 0 ${large_arc_flag} ${sweep_flag} ${this.x1} ${this.y1}`;
                if (this.includeCenterPoint) {
                    d += ` L ${this.cx} ${this.cy} Z`;
                }
                return svgPath({
                    d: d,
                    style: this.style,
                });
            }
        }

        // Returns an SVG <path> representing a "pie", i.e. a segment of a circle.
        // The segment has its center at (cx, cy), a radius of r and spans the (radian) angular
        // range from phi0 to phi1.
        function svgPie(cx, cy, r, phi0, phi1, style) {
            return new SvgCircleSegment(cx, cy, r, phi0, phi1, true, style);
        }

        // Returns an SVG <path> representing a circle segment.
        function svgArc(cx, cy, r, phi0, phi1, style) {
            style.fill = "none";  // Never fill an arc.
            return new SvgCircleSegment(cx, cy, r, phi0, phi1, false, style);
        }

        class SvgLine {
            constructor(x1, y1, x2, y2, style) {
                this.x1 = x1;
                this.y1 = y1;
                this.x2 = x2;
                this.y2 = y2;
                this.style = style;
            }
            get length() {
                const dx = this.x2 - this.x1;
                const dy = this.y2 - this.y1;
                return Math.sqrt(dx * dx + dy * dy);
            }
            svg() {
                const l = document.createElementNS("http://www.w3.org/2000/svg", 'line');
                l.setAttribute("x1", this.x1);
                l.setAttribute("y1", this.y1);
                l.setAttribute("x2", this.x2);
                l.setAttribute("y2", this.y2);
                if (this.style) {
                    Object.keys(this.style).forEach(k => { l.style[k] = this.style[k]; });
                }
                return l;
            }
        }

        class SvgText {
            constructor(text, x, y, classes = []) {
                this.x = x;
                this.y = y;
                this.text = text;
                this.classes = classes;
            }

            svg() {
                const t = document.createElementNS("http://www.w3.org/2000/svg", 'text');
                t.textContent = this.text;
                t.setAttribute("x", this.x);
                t.setAttribute("y", this.y);
                if (this.classes.length > 0) {
                    t.setAttribute("class", this.classes.join(" "));
                }
                return t;
            }
        }

        function gray(x) {
            const h = Math.round(255 * (0.4 + 0.5 * (1 - x)))
            return `rgb(${h}, ${h}, ${h})`;
        }

        function d2r(deg) {
            return deg / 180 * Math.PI;
        }

        function initEventListeners() {
            const cmd = document.getElementById("cmdFocallengths");
            cmd.addEventListener('click', e => {
                const inp = document.getElementById("inpFocallengths");
                const re = new RegExp("[ ,;]+");
                const s = inp.value.trim();
                if (!s) {
                    return;
                }
                nums = s.split(re).map(n => Number(n)).filter(n => n > 0);
                if (nums.length > 0) {
                    init(nums);
                }
            });
        }

        function init(focalLengths = []) {
            if (focalLengths.length == 0) {
                focalLengths = [14, 16, 20, 24, 35, 50, 70, 85, 105, 135, 200];
            }
            const r0 = 400;
            let r = r0;
            let i = 0;
            const svg = document.getElementById("aov_svg");
            svg.replaceChildren()
            const up = Math.PI * 3 / 2;
            let topElems = [];  // Elements that should be added last to appear on top.
            for (const f of focalLengths) {
                let phi = aov(f);
                const seg = svgPie(0, 0, r, up - phi / 2, up + phi / 2, { fill: gray(i / (focalLengths.length - 1)) });
                svg.appendChild(seg.svg());
                const lbl = new SvgText(String(f), seg.x1, seg.y1, classes = ["annot"]);
                svg.appendChild(lbl.svg());
                if (i == 0) {
                    // Add arc with ticks for good measure.
                    const arc = svgArc(0, 0, r, up - phi / 2, up + phi / 2, { stroke: "black" })
                    topElems.push(arc);
                    const stepRadians = 5 / 180 * Math.PI;
                    let theta = 0;
                    let n = 0;
                    while (theta < phi / 2 - stepRadians / 5) {
                        const ticklen = (n % 2 == 0) ? 10 : 6;
                        const x1 = r * Math.cos(up - theta);
                        const y1 = r * Math.sin(up - theta);
                        const x2 = (r - ticklen) * Math.cos(up - theta);
                        const y2 = (r - ticklen) * Math.sin(up - theta);
                        topElems.push(new SvgLine(x1, y1, x2, y2, { stroke: "black" }));
                        if (n > 0) {
                            topElems.push(new SvgLine(-x1, y1, -x2, y2, { stroke: "black" }));
                        }
                        theta += stepRadians;
                        n++;
                    }

                    // Add line for horizontal field of view scale.
                    const ln = new SvgLine(seg.x0, seg.y0, seg.x1, seg.y1, { stroke: "black" });
                    topElems.push(ln);
                    // Assume the line is 10m away.
                    const meter = Math.abs(seg.y0) / 10;
                    let tx = 0;
                    n = 0;
                    const ty = seg.y1;
                    while (tx < seg.x1 - meter / 2) {
                        const ticklen = (n % 5 == 0) ? 5 : 3;
                        topElems.push(new SvgLine(tx, ty - ticklen, tx, ty + ticklen, { stroke: "black" }));
                        if (n > 0) {
                            topElems.push(new SvgLine(-tx, ty - ticklen, -tx, ty + ticklen, { stroke: "black" }));
                        }
                        tx += meter;
                        n++;
                    }
                }
                r *= 1.05;
                i++;
            }
            topElems.forEach(e => svg.appendChild(e.svg()));

            svg.setAttribute("width", 2 * r0);
            svg.setAttribute("height", r);
            svg.setAttribute("viewBox", `${-r0} ${-r} ${2 * r0} ${r}`);
            // const pie = svgPie(200, 200, 130, d2r(270 - 30), d2r(270 + 30), { fill: "green" });
            // svg.appendChild(pie);
            // const arc = svgArc(200, 200, 130, d2r(270 - 30), d2r(270 + 30), { stroke: "red", "stroke-width": "3px" });
            // svg.appendChild(arc);
        }

        initEventListeners();
        init();
    </script>
</body>

</html>